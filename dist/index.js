import{Command as h}from"commander";import b from"inquirer";async function c(){return new h().name("jstack").description("A CLI to generate a nodejs project using typescript, with options for more specialized projects").parse(process.argv),await v()}var v=async()=>{let{appName:r}=await b.prompt({name:"appName",type:"input",message:"What will your project be called?",default:"jstack",transformer:t=>t.trim()});return r};import O from"path";import j from"path";import p from"path";import{fileURLToPath as P}from"url";var x=P(import.meta.url),A=p.dirname(x),m=p.join(A,"../");import C from"ora";import a from"fs-extra";import n from"chalk";import l from"inquirer";async function f({projectName:r,projectDir:t}){let o=j.join(m,"template/base"),i=C(`Scaffolding in: ${t}...
`).start();if(a.existsSync(t))if(a.readdirSync(t).length===0)r!=="."&&i.info(`${n.cyan.bold(r)} exists but is empty, continuing...
`);else{i.stopAndPersist();let{overwriteDir:e}=await l.prompt({name:"overwriteDir",type:"list",message:`${n.redBright.bold("Warning:")} ${n.cyan.bold(r)} already exists and isn't empty. How would you like to proceed?`,choices:[{name:"Abort installation (recommended)",value:"abort",short:"Abort"},{name:"Clear the directory and continue installation",value:"clear",short:"Clear"},{name:"Continue installation and overwrite conflicting files",value:"overwrite",short:"Overwrite"}],default:"abort"});e==="abort"&&(i.fail("Aborting installation..."),process.exit(1));let g=e==="clear"?"clear the directory":"overwrite conflicting files",{confirmOverwriteDir:w}=await l.prompt({name:"confirmOverwriteDir",type:"confirm",message:`Are you sure you want to ${g}?`,default:!1});w||(i.fail("Aborting installation..."),process.exit(1)),e==="clear"&&(i.info(`Emptying ${n.cyan.bold(r)} and creating t3 app..
`),a.emptyDirSync(t))}let s=r==="."?"App":n.cyan.bold(r);a.copySync(o,t),i.succeed(`${s} ${n.green("scaffolded successfully!")}
`)}async function d(r){let t=O.resolve(process.cwd(),r);await f({projectName:r,projectDir:t})}import u from"path";var y=r=>{let t=r.split("/"),o=t[t.length-1];if(o==="."){let e=u.resolve(process.cwd());o=u.basename(e)}let i=t.findIndex(e=>e.startsWith("@"));t.findIndex(e=>e.startsWith("@"))!==-1&&(o=t.slice(i).join("/"));let s=t.filter(e=>!e.startsWith("@")).join("/");return[o,s]};async function N(){let r=await c(),[t,o]=y(r);await d(o)}N();
//# sourceMappingURL=index.js.map